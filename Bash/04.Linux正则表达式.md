# liunx 中正则表达式的使用

## grep

> 根据用于指定的过滤条件（模式），对目标文本逐行进行匹配检查，打印匹配到的行

* 它的功能是从**文本文件**或**管道数据流**中筛选匹配的行和数据，同时也可以配合正则表达式

```shell
# option 匹配模式
# pattern 元字符或正则表达式
grep [options] [pattern] file
```

| 匹配模式   | 说明                        |
| ----- | --------------------------- |
| -v    | 排除匹配的结果 |
| -n    | 显示匹配的行与行号  |
| -i    | 不区分大小写      |
| -c    | 只统计匹配的行数     |
| -E    | 使用 egrep（支持扩展）命令       |
| -color=auto     | 为过滤的结果添加颜色       |
| -w    | 只匹配过滤的单词 |
| -o    | 只输出匹配的内容  |

```shell
# 找到所有关于 root 的参数
cat /etc/passwd | grep -i "root"
# 如果要显示行号，需要 -n 参数
cat /etc/passwd | grep -in "root"
# 如果想要排除某个不想要的，如(#)
cat /etc/passwd | grep -v "^#"
```

* 注意：在 linux 中，文件中所有换行的内容结尾都会增加一个 `$`

```shell
cat -en /etc/passwd
```

> 如果使用的是扩展的正则表达式，需要使用 `-E`

* 这些字符有：`+`、`|`、`()`、`{}`

```shell
find ~ -name "*.(md|txt)" | grep -E "vscode | docker"
```

## sed

> 流式的方式结合正则匹配快速的增删改查，查询的功能最常用的是过滤、取行

* sed 首先会读取文本内容，将内容存储到内存中，然后设计模式规则。
* 如果符合规则，处理内存数据；不符合规则的也会和符合规则的合到一起。所以单独使用 p 是没用的

```shell
sed [option] [command] [file]
```

| option   | 说明                                   |
|------ | ---------------------------------------- |
| -n     | 取消默认 sed 的输出，常与内置的 p 命令一起使用 |
| -i     | 直接将修改结果写入文件，如果不用 -i，修改的是内存数据 |
| -e     | 多次编辑，不需要管道符     |
| -r     | 支持正则扩展     |

* sed 常用的内置的命令字符

| command        | 说明                                  |
|----------------|---------------------------------------|
|   a            | append 对文本追加，在指定行后面添加一行/多行|
|   b            | delete 删除匹配行                      |
|   i            | insert 插入文本，在指定行前添加一行/多行   |
|   p            | print 打印匹配行的内容，通常与 -n 一起使用 |
|s/正则/替换内容/g | 匹配正则内容，然后替换内容（支持正则）      |

* sed 匹配范围

| 范围            | 说明                                  |
|----------------|---------------------------------------|
| 空地址          | 全文处理                               |
| 单地址          | 指定文件某一行                          |
| /pattern/      | 被模式匹配到的某一行                     |
| 范围区间        | 10,20->10～20 10,+5->从第10行向下5行 /pattern1/,/pattern2/|
| 步长           | 1~2 奇数，从 1 开始，两个步长（1，3，5，7） 2~2偶数（2,4,6,8），    |

```shell
sed -n "2,3p" .zshrc 
sed -n "2,+3p" .zshrc
sed -n "/proxy/p" .zshrc
# 删除和 game 有关的行，并且输出修改之后的，但是原文件不会变
sed "/proxy/d" .zshrc
# 删除和 game 有关的行，并且输出修改之后的，且原文件会变
sed -i "/proxy/d" .zshrc
# 替换所有想要替换的数据
sed -i "s/a/b/g" a.md
```

* <span style="color:red">注意: 如果是在 mac 上，一切修改操作都需要备份</span>

```bash
sed -i'.back' "s/ssss/star/g" a.md
```

> 如果想要批量替换，需要使用 `-e`

```bash
sed -i -e "s/a/b/g" -e "s/we/us/g" a.md
```

> 在行末尾添加数据

```bash
# linux 中如果想要换行，添加 \n 就可以
sed -i "1a my test" a.md
# 如果希望对每一行都成立，使用空范围
sed -i "a ---------" a.md
```

```bash
# mac \ 后还需要有一个空格
# 并且 mac 中不支持换行
sed -i'.fw' "1 a\ 
startup" a.md
```

实践，取 mac 的ip地址

```bash
ifconfig utun0 | sed -n "2p" | sed -e "s/^.*inet6 //" -e "s/\%.*$//"
```
